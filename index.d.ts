// Type definitions for algosdk 1.8.0
// Project: https://github.com/algorand/js-algorand-sdk
// Definitions by: Robert Zaremba <https://github.com/robert-zaremba>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

/** Declaration file generated by dts-gen */

export class Algod {
  constructor(token: string, baseServer: string, port: number, headers?: object);

  status(): Promise<NodeStatus>;
}

export class Algodv2 {
  // https://github.com/algorand/js-algorand-sdk/blob/develop/src/client/v2/algod/algod.js#L19
  constructor(token: string, baseServer: string, port: number, headers?: object);

  compile(source: string): Action<CompileOut>;
  status(): Action<any>;

  sendRawTransaction(rawSignedTxn: TxnBytes | TxnBytes[]): Action<TxResult>;
  getTransactionParams(): Action<SuggestedParams>;
  pendingTransactionInformation(txId: string): Action<ConfirmedTxInfo>;
  statusAfterBlock(lastround: number): Action<any>;
  accountInformation(address: string): Action<AccountInfo>;
}

export const OnApplicationComplete: {
  ClearStateOC: number;
  CloseOutOC: number;
  DeleteApplicationOC: number;
  NoOpOC: number;
  OptInOC: number;
  UpdateApplicationOC: number;
};

export namespace modelsv2 {
  function Account(...args: any[]): void;

  function Application(...args: any[]): void;

  function ApplicationLocalState(...args: any[]): void;

  function ApplicationParams(...args: any[]): void;

  function ApplicationStateSchema(...args: any[]): void;

  function Asset(...args: any[]): void;

  function AssetHolding(...args: any[]): void;

  function AssetParams(...args: any[]): void;

  function DryrunRequest(...args: any[]): void;

  function DryrunSource(...args: any[]): void;

  function TealKeyValue(...args: any[]): void;

  function TealValue(...args: any[]): void;
}

export class Kmd {
  constructor(token: string, baseServer: string, port: number);

  versions(): Promise<any>;
  listWallets(): Promise<Wallets>;
  initWalletHandle(walletid: string, password: string): Promise<WalletHandle>;
  listKeys(wallet_handle_token: string): Promise<Keys>;
  exportKey(wallet_handle_token: string, password: string, address: string): Promise<PrivKeyWrapper>;
}

export interface Wallets {
  wallets: WalletDetails[];
}

export interface WalletDetails {
  driver_name: string;
  driver_version: number;
  id: string;
  mnemonic_ux: boolean;
  name: string;
  supported_txs: string[];
}

export interface PrivKeyWrapper {
  private_key: Uint8Array;
}

export interface Keys {
  addresses: string[];
}

export interface WalletHandle {
  wallet_handle_token: string;
}

export interface Account {
  addr: string;
  sk: Uint8Array;
}

export interface CompileOut {
  hash: string;
  result: string;
}

// https://github.com/algorand/js-algorand-sdk/blob/develop/src/transaction.js
export interface Transaction {
  // fields copied from
  // https://github.com/algorand/js-algorand-sdk/blob/develop/src/transaction.js#L117
  from: ParsedAddress;
  to: ParsedAddress;
  fee: number;
  amount: number;
  firstRound: number;
  lastRound: number;
  note: string;
  genesisID: string;
  genesisHash: string;
  lease: number;

  closeRemainderTo: ParsedAddress;
  voteKey: string;
  selectionKey: string;
  voteFirst: any;
  voteLast: any;
  voteKeyDilution: any;

  assetIndex: number;
  assetTotal: number;
  assetDecimals: number;
  assetDefaultFrozen: any;
  assetManager: ParsedAddress;
  assetReserve: ParsedAddress;

  assetFreeze: ParsedAddress;
  assetClawback: ParsedAddress;
  assetUnitName: string;
  assetName: string;
  assetURL: string;
  assetMetadataHash: string;

  freezeAccount: string;
  freezeState: any;
  assetRevocationTarget: any;

  appIndex: any;
  appOnComplete: any;
  appLocalInts: any;
  appLocalByteSlices: any;
  appGlobalInts: any;
  appGlobalByteSlices: any;

  appApprovalProgram: any;
  appClearProgram: any;
  appArgs: any;
  appAccounts: any;
  appForeignApps: any;
  appForeignAssets: any;
  type: any;
  reKeyTo: string;

  addLease: (lease: Uint8Array | undefined, feePerByte?: number) => void;
  addRekey: (reKeyTo: string, feePerByte?: number) => void;
  bytesToSign: () => Uint8Array;
  signTxn: (sk: Uint8Array) => TxnBytes;
  toByte: () => Uint8Array;
  txID: () => string;

  from_obj_for_encoding: (txnForEnc: unknown) => Transaction;
  get_obj_for_encoding: () => unknown;
}

// an object created by `Transaction.signTxn` before serializing
export interface SignedTransaction {
  txn: Transaction;
  sig: Uint8Array;
}

// args Program arguments as array of Uint8Array arrays
export type LogicSigArgs = Uint8Array[];

export interface Subsig {
  pk: string;
  s: Uint8Array;
}

export interface MultiSig {
  subsig: Subsig[];
  thr: number;
  v: number;
}

export interface MultiSigAccount {
  // array of base32 encoded addresses
  addrs: string[];
  thr: number;
  v: number;
}

export class LogicSigBase {
  logic: Uint8Array;
  // args Program arguments as array of Uint8Array arrays
  args: LogicSigArgs;
  sig?: unknown;
  msig?: MultiSig;
}

export class LogicSig extends LogicSigBase {
  constructor(program: Uint8Array, args: LogicSigArgs);

  get_obj_for_encoding(): LogicSigBase;
  from_obj_for_encoding(encoded: LogicSigBase): LogicSig;

  // Performs signature verification
  verify(msg: Uint8Array): boolean;
  // Compute hash of the logic sig program (that is the same as escrow account address) as string address
  address(): string;
  // Creates signature (if no msig provided) or multi signature otherwise
  sign(secretKey?: Uint8Array, msig?: MultiSigAccount): void;
  // Signs and appends a signature
  appendToMultisig(secretKey: Uint8Array): void;
  // signs and returns program signature, without appending it to this object
  signProgram(secretKey: Uint8Array): Uint8Array;
  singleSignMultisig(secretKey: Uint8Array, msig: MultiSig): [Uint8Array, number];
  // serializes and encodes the LogicSig
  toByte(): Uint8Array;
  // deserializes a LogicSig which was serialized using toByte()
  fromByte(encoded: Uint8Array): LogicSig;
}

export interface TxSig {
  txID: string;
  // blob representing signed transaction data (it's `txn.get_obj_for_encoding()`)
  blob: Uint8Array;
}

export function Indexer(...args: any[]): any;

export function algosToMicroalgos(algos: any): any;

export function appendSignMultisigTransaction(multisigTxnBlob: any, { version, threshold, addrs }: any, sk: any): any;

export function assignGroupID(txns: any, from?: any): any;

export function computeGroupID(txns: any): any;

export function decodeObj(o: any): any;

export function encodeObj(o: any): any;

export function generateAccount(): Account;

/**
 * isValidAddress takes an Algorand address and checks if valid.
 * @param address Algorand address
 * @returns true if valid, false otherwise
 */
export function isValidAddress(addr: string): boolean;

/**
 * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.
 * @param address an Algorand address with checksum.
 * @returns the decoded form of the address's public key and checksum
 */
export function decodeAddress(a: string): Address;

/**
 * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.
 * @param address a raw Algorand address
 * @returns the address and checksum encoded as a string.
 */
export function encodeAddress(a: Uint8Array): string;

/**
 * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.
 * @param version mutlisig version
 * @param threshold multisig threshold
 * @param addrs  array of encoded addresses
 */
export function multisigAddress(account: {version: number; threshold: number; addrs: string[]}): string;

// Calls LogicSig.fromByte
export function logicSigFromByte(encoded: Uint8Array): LogicSig;

/**
 * tealSign creates a signature compatible with ed25519verify opcode from contract address
 * @param sk - uint8array with secret key
 * @param data - buffer with data to sign
 * @param contractAddress string representation of teal contract address (program hash)
 */
export function tealSign(sk: Uint8Array, data: Uint8Array, contractAddress: string): Uint8Array;

/**
 * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes
 * @param sk - uint8array with secret key
 * @param data - buffer with data to sign
 * @param program - buffer with teal program
 */
export function tealSignFromProgram(sk: Uint8Array, data: Uint8Array, program: Uint8Array): Uint8Array;

/**
 * encodeUnsignedTransaction takes a completed Transaction object, such as from the makeFoo
 * family of transactions, and converts it to a Buffer
 * @param t the completed Transaction object
 * @returns Uint8Array
 */
export function encodeUnsignedTransaction(t: Transaction): Uint8Array;

/**
 * decodeUnsignedTransaction takes a Buffer (as if from encodeUnsignedTransaction) and converts it to a Transaction object
 * @param b the Uint8Array containing a transaction
 * @returns Transaction
 */
export function decodeUnsignedTransaction(b: Uint8Array): Transaction;

/**
 * decodeSignedTransaction takes a Buffer (from transaction.signTxn) and converts it to an object
 * containing the Transaction (txn), the signature (sig), and the auth-addr field if applicable (sgnr)
 * @param b the Uint8Array containing a transaction
 * @returns Object containing a Transaction, the signature, and possibly an auth-addr field
 */
export function decodeSignedTransaction(b: Uint8Array): SignedTransaction;

export function makeApplicationClearStateTxn(from: string, suggestedParams: any, appIndex: number,
  appArgs?: Uint8Array[], accounts?: any, foreignApps?: any, foreignAssets?: any,
  note?: Uint8Array, lease?: Uint8Array, rekeyTo?: string): any;

export function makeApplicationCloseOutTxn(from: string, suggestedParams: any, appIndex: number,
  appArgs?: Uint8Array[], accounts?: any, foreignApps?: any, foreignAssets?: any,
  note?: Uint8Array, lease?: Uint8Array, rekeyTo?: string): any;

export function makeApplicationCreateTxn(from: string, suggestedParams: any, onComplete: number,
  approvalProgram: any, clearProgram: any, numLocalInts: any, numLocalByteSlices: any,
  numGlobalInts: any, numGlobalByteSlices: any, appArgs?: Uint8Array[], accounts?: any, foreignApps?: any,
  foreignAssets?: any, note?: Uint8Array, lease?: Uint8Array, rekeyTo?: string): any;

export function makeApplicationDeleteTxn(from: string, suggestedParams: any, appIndex: number,
  appArgs?: Uint8Array[], accounts?: any, foreignApps?: any, foreignAssets?: any, note?: Uint8Array,
  lease?: Uint8Array, rekeyTo?: string): any;

export function makeApplicationNoOpTxn(from: string, suggestedParams: any, appIndex: number,
  appArgs?: Uint8Array[], accounts?: any, foreignApps?: any, foreignAssets?: any, note?: Uint8Array,
  lease?: Uint8Array, rekeyTo?: string): any;

export function makeApplicationOptInTxn(from: string, suggestedParams: any, appIndex: number,
  appArgs?: Uint8Array[], accounts?: any, foreignApps?: any, foreignAssets?: any, note?: Uint8Array,
  lease?: Uint8Array, rekeyTo?: string): any;

export function makeApplicationUpdateTxn(from: string, suggestedParams: any, appIndex: number,
  approvalProgram: any, clearProgram: any, appArgs?: Uint8Array[], accounts?: Address[], foreignApps?: any,
  foreignAssets?: any, note?: Uint8Array, lease?: Uint8Array, rekeyTo?: Address): any;

export function makeAssetConfigTxn(from: any, fee: any, firstRound: any, lastRound: any,
  note: any, genesisHash: any, genesisID: any, assetIndex: any, manager: any, reserve: any,
  freeze: any, clawback: any, strictEmptyAddressChecking: any): any;

export function makeAssetConfigTxnWithSuggestedParams(from: any, note: any, assetIndex: any,
  manager: any, reserve: any, freeze: any, clawback: any, suggestedParams: any,
  strictEmptyAddressChecking: any): any;

export function makeAssetCreateTxn(from: any, fee: any, firstRound: any, lastRound: any,
  note: any, genesisHash: any, genesisID: any, total: any, decimals: any, defaultFrozen: any, manager: any,
  reserve: any, freeze: any, clawback: any, unitName: any, assetName: any, assetURL: any,
  assetMetadataHash: any): any;

export function makeAssetCreateTxnWithSuggestedParams(from: any, note: any, total: any,
  decimals: any, defaultFrozen: any, manager: any, reserve: any, freeze: any,
  clawback: any, unitName: any, assetName: any, assetURL: any, assetMetadataHash: any,
  suggestedParams: any): Transaction;

export function makeAssetDestroyTxn(from: any, fee: any, firstRound: any, lastRound: any, note: any, genesisHash: any, genesisID: any, assetIndex: any): any;

export function makeAssetDestroyTxnWithSuggestedParams(from: any, note: any, assetIndex: any, suggestedParams: any): any;

export function makeAssetFreezeTxn(from: any, fee: any, firstRound: any, lastRound: any,
  note: any, genesisHash: any, genesisID: any, assetIndex: any, freezeTarget: any, freezeState: any): any;

export function makeAssetFreezeTxnWithSuggestedParams(from: any, note: any, assetIndex: any, freezeTarget: any, freezeState: any, suggestedParams: any): any;

export function makeAssetTransferTxn(from: any, to: any, closeRemainderTo: any,
  revocationTarget: any, fee: any, amount: any, firstRound: any, lastRound: any, note: any, genesisHash: any, genesisID: any, assetIndex: any): any;

export function makeAssetTransferTxnWithSuggestedParams(from: any, to: any, closeRemainderTo: any,
  revocationTarget: any, amount: any, note: any, assetIndex: any, suggestedParams: any): any;

export function makeKeyRegistrationTxn(from: any, fee: any, firstRound: any, lastRound: any,
  note: any, genesisHash: any, genesisID: any, voteKey: any, selectionKey: any, voteFirst: any, voteLast: any,
  voteKeyDilution: any): any;

export function makeKeyRegistrationTxnWithSuggestedParams(from: any, note: any, voteKey: any,
  selectionKey: any, voteFirst: any, voteLast: any, voteKeyDilution: any, suggestedParams: any): any;

export function makeLogicSig(program: Uint8Array, args: LogicSigArgs): LogicSig;

export function makePaymentTxn(from: any, to: any, fee: any, amount: any, closeRemainderTo: any,
  firstRound: any, lastRound: any, note: any, genesisHash: any, genesisID: any): any;

export function makePaymentTxnWithSuggestedParams(from: any, to: any, amount: any, closeRemainderTo: any, note: any, suggestedParams: any): any;

export function masterDerivationKeyToMnemonic(mdk: any): string;

/**
 * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.
 * @param multisigTxnBlobs a list of blobs representing encoded multisig txns
 * @returns typed array msg-pack encoded multisig txn
 */
export function mergeMultisigTransactions(multisigTxnBlobs: Uint8Array[]): Uint8Array;

export function microalgosToAlgos(microalgos: any): any;

export function mnemonicToMasterDerivationKey(mn: string): any;

export function mnemonicToSecretKey(mn: string): Account;

export function secretKeyToMnemonic(sk: Uint8Array): string;

export function signBid(bid: any, sk: any): any;

export function signBytes(bytes: any, sk: any): any;

/**
 * signLogicSigTransaction takes  a raw transaction and a LogicSig object and returns a logicsig
 * transaction which is a blob representing a transaction and logicsig object.
 * @param Object dictionary containing constructor arguments for a transaction
 * @param lsig logicsig object
 * @returns TxSig - Object containing txID and blob representing signed transaction.
 * @throws error on failure
 */
export function signLogicSigTransaction(txn: any, lsig: LogicSig): TxSig;

/**
 * signLogicSigTransactionObject takes transaction.Transaction and a LogicSig object and returns a logicsig
 * transaction which is a blob representing a transaction and logicsig object.
 * @param txn transaction.Transaction
 * @param lsig logicsig object
 * @returns TxSig - Object containing txID and blob representing signed transaction.
 */
export function signLogicSigTransactionObject(txn: Transaction, lsig: LogicSig): TxSig;

export function signMultisigTransaction(txn: any, { version, threshold, addrs }: any, sk: any): any;

export function signTransaction(txn: Transaction, sk: any): any;

export function verifyBytes(bytes: any, signature: any, addr: any): any;

export namespace ERROR_INVALID_MICROALGOS {
  const message: string;
  const name: string;
  const stack: string;

  function toString(): any;
}

export namespace ERROR_MULTISIG_BAD_SENDER {
  const message: string;
  const name: string;
  const stack: string;

  function toString(): any;
}

// *************************
//     Support types

export class Action<T> {
  do(headers?: Record<string, unknown>): Promise<T>;
}

export interface RequestError extends Error {
  statusCode?: number;
  text: string;
  body?: {
    message?: string;
  };
  error?: Error;
}

export interface NodeStatus {
  catchpoint: string;
  'catchpoint-acquired-blocks': number;
  'catchpoint-processed-accounts': number;
  'catchpoint-total-accounts': number;
  'catchpoint-total-blocks': number;
  'catchup-time': number;
  'last-catchpoint': string;
  'last-round': number;
  'last-version': string;
  'next-version': string;
  'next-version-round': number;
  'next-version-supported': boolean;
  'stopped-at-unsupported-round': boolean;
  'time-since-last-round': number;
}

export interface TxResult {
  txId: string;
}

export interface ConfirmedTxInfo {
  'confirmed-round': number;
  "asset-index": number;
  'application-index': number;
  'global-state-delta': string;
  'local-state-delta': string;
}

export interface SuggestedParams {
  flatFee: boolean;
  fee: number;
  firstRound: number;
  lastRound: number;
  genesisID: string;
  genesisHash: string;
}

export interface ParsedAddress {
  publicKey: string;
}

export interface Address {
  publicKey: Uint8Array;
  checksum: Uint8Array;
}

export type TxnBytes = Uint8Array;

export interface AccountAssetInfo {
  amount: number;
  'asset-id': number;
  creator: string;
  'is-frozen': boolean;
}

export interface AccountInfo {
  address: string;
  assets: AccountAssetInfo[];
  amount: number;
  "amount-without-pending-rewards": number;
  'pending-rewards': number;
  'reward-base': number;
  rewards: number;
  round: number;
  status: string;
  'apps-local-state': any;
  'apps-total-schema': any;
  'created-apps': any;
  'created-assets': any;
}
